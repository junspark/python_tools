def balogh_march14_xyNs_hydra '{
    # take diffraction data in xy grid over N loops with a sleep time between loops
    if ($# != 11)
    {
        print "Usage: balogh_march14_xyNs [fname] [Nframe] [tframe] [x0] [Nx] [dx] [y0] [Ny] [dy] [nLoop] [tsleep]"
        exit
    }
    local stX nX dX stY nY dY XX YY
    local nLoop tsleep
    local iLoop yLoop xLoop 
    
    stX=$4; nX=$5; dX=$6;
    stY=$7; nY=$8; dY=$9;
    nLoop=$10; tsleep=$11;
    
    for (iLoop=0; iLoop<nLoop; iLoop++)
    {
        for (yLoop=0; yLoop<nY; yLoop++)
        {
            YY=stY+yLoop*dY  
            umv samYC YY
            for (xLoop=0; xLoop<nX; xLoop++)
            {
                XX=stX+xLoop*dX
                p "samXC = " XX " samYC = " YY
                umv samXC XX
                balogh_march14_hydra_expose $1 $2 $3
            }
        }
        sleep(tsleep) 
    }
    beep_dac
}'

def balogh_march14_xyNs '{
    # take diffraction data in xy grid over N loops with a sleep time between loops
    if ($# != 11)
    {
        print "Usage: balogh_march14_xyNs [fname] [Nframe] [tframe] [x0] [Nx] [dx] [y0] [Ny] [dy] [nLoop] [tsleep]"
        exit
    }
    local stX nX dX stY nY dY XX YY
    local nLoop tsleep
    local iLoop yLoop xLoop 
    
    stX=$4; nX=$5; dX=$6;
    stY=$7; nY=$8; dY=$9;
    nLoop=$10; tsleep=$11;
    
    for (iLoop=0; iLoop<nLoop; iLoop++)
    {
        for (yLoop=0; yLoop<nY; yLoop++)
        {
            YY=stY+yLoop*dY  
            umv samYC YY
            for (xLoop=0; xLoop<nX; xLoop++)
            {
                XX=stX+xLoop*dX
                p "samXC = " XX " samYC = " YY
                umv samXC XX
                balogh_march14_GE_expose $1 $2 $3
            }
        }
        sleep(tsleep) 
    }
    beep_dac
}'

"""
def balogh_march14_move_mts '{
    # take diffraction data in xy grid over N loops with a sleep time between loops, use mts to define y-movement
    # MPT on mts should be actively running prior to starting this macro, which has loop for moving to 2 different positions
    if ($# != 5)
    {
        print "Usage: balogh_march14_xyNs_mts [fname] [Nframe] [tframe] [nloop] [tsleep]"
        exit
    }
    nLoop=$4; tsleep=$5;
    
    for (iLoop=0; iLoop<nLoop; iLoop++)
    {
        p date(), iLoop
        balogh_march14_GE_expose $1 $2 $3

        
        send_mts_trigger1; #this tells MPT program to move crosshead/sample vertically to next position
        sleep(0.1)

        p "waiting for first movement to finish"
        wait_mts_trigger1; #wait for movement to finish
        balogh_march14_GE_expose $1 $2 $3
        sleep(tsleep)
        send_mts_trigger1; #move to next position

        p "waiting for second movement to finish"
        sleep(0.1)
        wait_mts_trigger1; #wait for movement to finish
        sleep(tsleep) 
    }
}'
"""

#*************************************************************
def balogh_march14_GE_expose '{
    # does a GE exposure for user-defined time
    # control box for detectors must be switched to GE3 - D setting
	if ($# != 3)
	{
        print "Usage: balogh_march14_GE_expose [fname Nframe tframe]"
        exit
	}   
	
    GE_fname="$1"
    GE_Nframe=$2
    GE_tframe=$3
    GE_fnum=get_hydra_FileNumber(1)

    delt=0.05; #wait time between epics commands
    
    Cclose; #arm shutters
    check_beam_shutterA
    Sopen; #arm shutters 	  
    shutter_sweep; #shutter will be controlled be GE TTL

    set_hydra_FileName $1
    set_hydra_NumberOfImagesPerDetTrig $2
    
    det_trig GE_tframe
    
    ct($2*$3+1);  #count scalers for absorption/i0 info
    det_wait
    
    # beep_dac;

    parfilename="/home/beams/S1IDUSER/new_data/balogh_march14/balogh_march14_exposures.par"

    #record beamline and exposure data in parameter file after exposure
    initialize_beamline_parameters;
    get_beamline_parameters;
    
    on(parfilename)
    p date(),GE_fname,GE_fnum,GE_tframe,GE_Nframe,S[0],S[1],S[2],S[8],S[9],S[10],S[11],S[12],p1Hs,p1Vs,Iring,energy,energy_cal,preamp1,preamp2,sammy_x,sammy_y,sammy_z,sammy_x2,sammy_z2,sammy_phi,bp_c,keyence2,cross,load,mts3,mts4,temp1,temp2,temp3,temp4,etoutpower,attn1,attn2,attn3,attn4
    off(parfilename)
    close(parfilename)
    
    shutter_manual; #reset to allow Copen/Cclose shutter commands
}'

#*************************************************************
def balogh_march14_hydra_expose '{
    # does a GE exposure for user-defined time
    # control box for detectors must be switched to GE3 - D setting
	if ($# != 3)
	{
        print "Usage: balogh_march14_GE_expose [fname Nframe tframe]"
        exit
	}   
	
    # umv stopX 0
    GE_fname="$1"
    GE_Nframe=$2
    GE_tframe=$3
    
    GE_fnum1=get_hydra_FileNumber(1)
    GE_fnum3=get_hydra_FileNumber(2)
    GE_fnum4=get_hydra_FileNumber(3)

    delt=0.05; #wait time between epics commands
    
    Cclose; #arm shutters
    check_beam_shutterA #################
    Sopen; #arm shutters 	  
    shutter_sweep; #shutter will be controlled be GE TTL
    
    set_hydra_FileName $1
    set_hydra_NumberOfImagesPerDetTrig $2
    
    det_trig GE_tframe

    ct($2*$3+1);  #count scalers for absorption/i0 info
    det_wait
    
    parfilename="/home/beams/S1IDUSER/new_data/balogh_march14/balogh_march14_exposures.par"

    #record beamline and exposure data in parameter file after exposure
    initialize_beamline_parameters;
    get_beamline_parameters;
    
    on(parfilename)
    p date(),GE_fname,GE_fnum1,GE_tframe,GE_Nframe,S[0],S[1],S[2],S[8],S[9],S[10],S[11],S[12],p1Hs,p1Vs,Iring,energy,energy_cal,preamp1,preamp2,sammy_x,sammy_y,sammy_z,sammy_x2,sammy_z2,sammy_phi,bp_c,keyence2,cross,load,mts3,mts4,temp1,temp2,temp3,temp4,etoutpower,attn1,attn2,attn3,attn4
    p date(),GE_fname,GE_fnum3,GE_tframe,GE_Nframe,S[0],S[1],S[2],S[8],S[9],S[10],S[11],S[12],p1Hs,p1Vs,Iring,energy,energy_cal,preamp1,preamp2,sammy_x,sammy_y,sammy_z,sammy_x2,sammy_z2,sammy_phi,bp_c,keyence2,cross,load,mts3,mts4,temp1,temp2,temp3,temp4,etoutpower,attn1,attn2,attn3,attn4
    p date(),GE_fname,GE_fnum4,GE_tframe,GE_Nframe,S[0],S[1],S[2],S[8],S[9],S[10],S[11],S[12],p1Hs,p1Vs,Iring,energy,energy_cal,preamp1,preamp2,sammy_x,sammy_y,sammy_z,sammy_x2,sammy_z2,sammy_phi,bp_c,keyence2,cross,load,mts3,mts4,temp1,temp2,temp3,temp4,etoutpower,attn1,attn2,attn3,attn4
    off(parfilename)
    close(parfilename)
    
    shutter_manual; #reset to allow Copen/Cclose shutter commands
}'

#*************************************************************
def initialize_beamline_parameters '{
    # set values to default value
    dval=999;
    energy_cal=dval; sammy_x=dval; sammy_y=dval; sammy_z=dval; sammy_x2=dval; sammy_z2=dval; sammy_phi=dval;
    bp_c=dval; keyence2=dval; cross=dval; load=dval; mts3=dval; mts4=dval; temp1=dval; temp2=dval; temp3=dval; temp4=dval;
    etoutpower=dval;
    attn1=dval; attn2=dval; attn3=dval; attn4=dval;
}'

#*************************************************************

def get_beamline_parameters  '{
    # grab relevant data
    get_angles
    sammy_x=A[samXC]; sammy_y=A[samYC]; sammy_z=A[samZ]
    sammy_x2=A[geX2]; 
    sammy_phi=A[aero];sammy_z2=A[hydraZ];
    
    p1Hs=epics_get("1idc:m62.RBV");p1Vs=epics_get("1idc:m64.RBV");
    Iring=epics_get("BL01:srCurrent");

    bp_c=epics_get("1id:userCalcOut9.VAL"); #splitIC at C entrance, converted to position in mm
    keyence2=epics_get("1id:Keyence:1:ch2.VAL");
    cross=epics_get("1id:D2Ch1_calc.VAL");
    load=epics_get("1id:D2Ch2_calc.VAL");
    mts3=epics_get("1id:D2Ch3_calc.VAL");
    mts4=epics_get("1id:D2Ch4_calc.VAL");
    
    temp1=epics_get("1id:ET_RI:Temp1");
    temp2=epics_get("1id:ET_RI:Temp2");
    temp3=epics_get("1id:ET_RI:Temp3");
    temp4=epics_get("1idc:DP41:s1:temp.VAL");
    # etoutpower=epics_get("1id:ET_RI:OP1");  ## CONTROLLER 1 DIED
    etoutpower=epics_get("1id:ET_RI:OP2");
    
    energy=epics_get("1id:userTran3.A");

    preamp1=epics_get("1idc:A3sens_num.VAL");
    preamp2=epics_get("1idc:A4sens_num.VAL");
    
    attn1=epics_get("1id:9440:1:bo_0.VAL");
    attn2=epics_get("1id:9440:1:bo_1.VAL");
    attn3=epics_get("1id:9440:1:bo_2.VAL");
    attn4=epics_get("1id:9440:1:bo_3.VAL");
}'

#*************************************************************

def GE3_handshake_epics '{
    # check if GE is idle using epics Area Detector Control application
    poll_time=0.1;
    Ncheck_max=2500;
    GE_address="GE3:cam1";
    
    icheck=0; sleep(poll_time)
    while (epics_get(sprintf("%s:DetectorState_RBV",GE_address)) != "IDLE")
    {
       icheck=icheck+1;   
       sleep(poll_time)
       if (icheck > Ncheck_max)
          {
          print "Exiting as waited too long for GE - check detector computer and restart programs / reboot as needed"
          exit
          }   
    }
    sleep(poll_time) #extra safety factor
}'

#*************************************************************
def beep_dac '{
  epics_put("1id:DAC1_8.VAL",6); #send warning beep to world
  sleep(1);
  epics_put("1id:DAC1_8.VAL",0);
}'

"""
# 
def wait_mts_trigger1 '{
# epics_put("1id:9440:1:bi_11.PROC",1); sleep(0.1);
 state_start=epics_get("1id:9440:1:bi_11.VAL"); sleep(0.1);
 state=epics_get("1id:9440:1:bi_11.VAL"); sleep(0.1);
  while (state==state_start)
   {
   epics_put("1id:9440:1:bi_11.PROC",1);
   sleep(0.1);
   state=epics_get("1id:9440:1:bi_11.VAL");
   sleep(0.1)
   }
 }'
 """
